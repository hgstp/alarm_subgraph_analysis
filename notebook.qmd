---
bibliography: references.bib 
authors: # see https://quarto.org/docs/journals/authors.html for further options
  - name: Stephan Haug
    orcid: 0000-0002-4572-9087
    affiliation: "Technical University of Munich"
    country: Germany
  - name: Oleksandr Zadorozhnyi
    orcid: 0000-0002-3725-4931
    country: Germany
---

# ALARM Subgraph Analysis


| Resource | Information |
|----|----|
| Data DOI | [10.5281/zenodo.14793281](https://doi.org/10.5281/zenodo.14793281) |
| GitHub | [Git](https://github.com/hgstp/alarm_subgraph_analysis)  |
| Short Description | The text describes the subgraph selection problem in large graphs $G$. The main objective is to find a smaller subgraph $S$ that is a meaningful and informative representation of the original graph $G$. |

: {.striped}

## Introduction

Given a large graph $G = (V, E)$, where $V$ represents the set of nodes and $E$ represents the set of edges, the goal is to select a subgraph $S = (V_s, E_s)$ from G such that S is a meaningful and informative representation of the original graph $G$. The subgraph selection problem involves finding an optimal or near-optimal subgraph that satisfies certain criteria or objectives.

In the context of graphical modelling the problem of subgraph selection corresponds to the problem of preserving the conditional independence relationship in the subgraph $S$ which has to be transferred from the underlying graph $G$.

Furthermore, it is important to be able to evaluate the results of the structure learning algorithms (learned on the data) taking as a ground truth the selected subgraph.

### Loading the Data

For our analysis we will need the following packages.
```{r}
#| message: false
# Used packages, only for information.
library(bnlearn)
library(qgraph)
library(igraph)
library(pcalg)
library(huge)
library(zen4R)
library(dplyr)
```

To read files into R hosted on Zenodo, one can use the [zen4R](https://cran.r-project.org/web/packages/zen4R/vignettes/zen4R.html) package. One starts by setting up the ZenodoManager

```{r}
zenodo <- ZenodoManager$new()
```

The ALARM dataset is contained in the Zenodo record [10.5281/zenodo.14793281]( https://doi.org/10.5281/zenodo.14793281). The record contains two data objects, which can be listed with the following command.

```{r}
#| message: false
rec <- zenodo$getRecordByDOI("10.5281/zenodo.14793281")
files <- rec$listFiles(pretty = TRUE)
files
```


The file `alarm.csv` contains the raw data and will be downloaded in the next step using the readr package.

```{r}
#| message: false
alarm_df <- readr::read_csv(files[2, 4])
alarm_df <- alarm_df |> 
  mutate(across(everything(), ~ case_when(
    .x == "FALSE" ~ 0, .x == "TRUE" ~ 1,
    .x == "ZERO" ~ 0, .x == "LOW" ~ 1, .x == "NORMAL" ~ 2,
    .x == "HIGH" ~ 3, .x == "ONESIDED" ~ 3, .x == "ESOPHAGEAL"~  4)))
alarm_df
```

The second file in the Zenodo record describes the "true" graph proposed for the ALARM dataset in @ScutariDenis2021. To read in the bif file, we can use the function `read.bif()` from the bnlearn package. It creates a bn.fit object, which can be plotted using `graphviz.plot()`.


```{r}
true_graph <- read.bif(files[1, 4])
graphviz.plot(true_graph, shape = "circle", fontsize = 20)
```



#### Applying a nonparanormal transformation to standardize the data

```{r}
alarm_df <- huge.npn(alarm_df)

```

Defining "true" graph as proposed for the ALARM dataset in bnlearn

```{r}
# "True" Graph ALARM
dag_alarm = empty.graph(names(alarm))
modelstring(dag_alarm) = paste0("[HIST|LVF][CVP|LVV][PCWP|LVV][HYP][LVV|HYP:LVF]",                    "[LVF][STKV|HYP:LVF][ERLO][HRBP|ERLO:HR][HREK|ERCA:HR][ERCA][HRSA|ERCA:HR]",
"[ANES][APL][TPR|APL][ECO2|ACO2:VLNG][KINK][MINV|INT:VLNG][FIO2]",            "[PVS|FIO2:VALV][SAO2|PVS:SHNT][PAP|PMB][PMB][SHNT|INT:PMB][INT]",              "[PRSS|INT:KINK:VTUB][DISC][MVS][VMCH|MVS][VTUB|DISC:VMCH]",                    "[VLNG|INT:KINK:VTUB][VALV|INT:VLNG][ACO2|VALV][CCHL|ACO2:ANES:SAO2:TPR]",
"[HR|CCHL][CO|HR:STKV][BP|CO:TPR]", sep = "")

qgraph::qgraph(dag_alarm, legend.cex = 0.3,
       asize = 2, edge.color="black", vsize= 4)
```

Choosing the nodes to consider in the subgraph selection problem

```{r}
subgraph_nodes <- c("INT","VALV","LVF","LVV","PCWP","HR","CCHL",
                    "CVP","HYP","HRSA","ERCA")
```

## Subgraph selection procedures

The __first procedure__ we consider is a simple subsetting of the edges adjacent to the vertices in the `subgraph_nodes` set. We can accomplish this using the `subgraph()` function from the bnlearn package.

```{r}
procedure1 <- bnlearn::subgraph(dag_alarm, subgraph_nodes)
qgraph::qgraph(procedure1, legend.cex = 0.3, asize = 2,
       edge.color = "black", vsize = 5)
```

**Second** procedure selects the subgraph based on the following heuristics:

We are given the ground truth DAG $G=(V, E)$ with corresponding joint distribution $\mathsf{P}_V$, and a subset of vertices $V_{s} \subset V$. The goal is to find the corresponding set of vertices $E_{s}$ such that the distribution $\mathsf{P}_{V_s}$ corresponding to  $(V_s, E_s)$ does not contradict the structure of the distribution $P_{V}$. 


Let $G = (V,E)$ be the original directed acyclic graph, and $P_{V}$ is the joint distribution of random variables from $V$.

We select two vertices and verify if these vertices are $d$-connected given all other vertices in $V_{s}$. If they are not $d$-connected, there is no association (no arrow in any direction). Otherwise, we have an association, but with unknown direction. If one of the directions leads to a cycle in the original graph, we resolve it and keep the other direction, otherwise we keep both directions and then get the CPDAG.

We need to consider all pairs of nodes contained in `subgraph_nodes`. There exists `r dim(combn(subgraph_nodes,2))` pairs in total.

The process of checking the $d$-connectivity of all pairs of nodes, is implemented in the following function.

```{r}
extract_subgraph <- function(dag, nodes){
  sg <- bnlearn::subgraph(dag,nodes) # procedure 1 (to be discussed)
  combinations <- combn(nodes,2) # all combinations of 2 distinct nodes in "nodes"
  n <- dim(combinations)[2]
  for (i in 1:n){
    observed <- nodes[nodes!=combinations[1,i] & nodes!=combinations[2,i]] # V'\{v,w}
    if (!is.element(combinations[1,i], nbr(sg, combinations[2,i])) & # check if there exists an edge already
        !bnlearn::dsep(dag,combinations[1,i],combinations[2,i])){ ### check if d-connected
      sg <- set.edge(sg, from = combinations[1,i], to = combinations[2,i]) ### undirected edge in case d-connected
    }
  }
  return(cpdag(sg)) ### to be discussed: return(cpdag(sg))
}

```


Based on the second procedure we get the following graph.


```{r}
procedure2 <- extract_subgraph(dag_alarm, subgraph_nodes)
qgraph::qgraph(procedure2, legend.cex = 0.3,
       asize=2,edge.color="black", vsize= 5)
```


The **third** procedure creates a partial ancestral graph (PAG) for the observable vertices in the subset-graph with respect to the latent variables in the vertices set $V \setminus V^{'}$.

PAGs are graphs which are used to represent causal relationships in situations where the exact underlying causal structure is not fully known or observable. In our case we observe the variables in the set $V^{'}$. Based on the covariance matrix from the observed data in $V^{'}$ we generate.


Subsetting the dataset according to "subgraph_nodes" selection

```{r}
alarm_df_subset <- as_tibble(alarm_df) |> 
  select(all_of(subgraph_nodes))
```

__Step 1:__ Compute the correlation matrix for the observed variables contained in `alarm_df_subset`.

```{r}
cor_matrix <- cor(alarm_df_subset)
```

__Step 2:__ Provide necessary information for the algorithm to work on. 

```{r}
indepTest <- pcalg::gaussCItest
suffStat <- list(C = cor_matrix, n = 1000)
```

__Step 3:__ Apply the FCI algorithm to the selected vertices, using the oracle correlation matrix.

```{r}
normal.pag <- pcalg:: fci(suffStat, indepTest, alpha = 0.05, 
                          labels = subgraph_nodes)

```

__Step 4:__ Plot the resulting PAG (Partial Ancestral Graph).

```{r}
qgraph(normal.pag@amat, asize=4, edge.color="black", vsize= 5)
```


Applying constraint-based algorithms

```{r}
#| warning: false
#| message: false
Res_stable <-pc.stable(alarm_df_subset)

Res_iamb <- iamb(alarm_df_subset)

Res_gs <- gs(alarm_df_subset)

Res_fiamb <- fast.iamb(alarm_df_subset)

Res_mmpc <- mmpc(alarm_df_subset)
```

Applying score-based algorithms

```{r}
Res_hc <- hc(alarm_df_subset)
Res_tabu <- tabu(alarm_df_subset)
```

The resulting subgraphs are shown below.

```{r}
#| layout-ncol: 3

qgraph(procedure1, title = "Procedure 1")
qgraph(procedure2, title = "Procedure 2")
qgraph(Res_stable, title = "PC")
qgraph(Res_iamb, title = "IAMB")
qgraph(Res_gs, title = "GS")
qgraph(Res_fiamb, title = "FIAMB")
qgraph(Res_mmpc, title = "MMPC")
qgraph(Res_hc, title = "HC")
qgraph(Res_tabu, title = "tabu")
```

Evaluate the performance by computing the number of true positives, false positives, and false negatives, as well as the structural hamming distance.

```{r}

measure  <-  function(estim, true){
  result <- matrix(1,4)
  com <- bnlearn::compare(estim, true)
  shd <- bnlearn::shd(estim,true)
  result <- data.frame(
    metric = c("true positives","false positives","false negatives","structural hamming distance"),
    value = c(com$tp, com$fp, com$fn, shd)
  )
  return(result)
}



```

Metric evaluation for procedure 1

```{r}
measure(Res_stable, procedure1)
measure(Res_iamb, procedure1)
measure(Res_gs, procedure1)
measure(Res_fiamb, procedure1)
measure(Res_mmpc, procedure1)
measure(Res_hc, procedure1)
measure(Res_tabu, procedure1)
```

Metric evaluation for procedure 2

```{r}
measure(Res_stable, procedure2)
measure(Res_iamb, procedure2)
measure(Res_gs, procedure2)
measure(Res_fiamb, procedure2)
measure(Res_mmpc, procedure2)
measure(Res_hc, procedure2)
measure(Res_tabu, procedure2)
```







```{r}
#| eval: false
source("../../close_environment.R")
```

```{r}
sessionInfo()
```


### Citing this Notebook {.unnumbered}

Please cite _ALARM Subgraph Analysis_ with the following bib item.

``` bibtex
@misc{HaugZadorozhnyi2025,
  title = {ALARM Subgraph Analysis},
  author = {Haug, Stephan and Zadorozhnyi, Oleksandr},
  year = {2025}
}
```

When using the `ALARM` dataset, please give credit to the original author: @JSSv035i03.

### Additional Information {.unnumbered}

**License Information:** Please follow the above DOI for license information of data and code.

**Contact:** If you have suggestions, feel free to [create an issue](https://github.com/hgstp/alarm_subgraph_analysis/issues) or contact the authors (haug@tum.de).
